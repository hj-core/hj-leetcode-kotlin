Index: src/main/kotlin/com/hj/leetcode/kotlin/problem2458/Solution.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.hj.leetcode.kotlin.problem2458\r\n\r\nimport com.hj.leetcode.kotlin.common.model.TreeNode\r\nimport kotlin.math.max\r\nimport kotlin.math.min\r\n\r\n/**\r\n * LeetCode page: [2458. Height of Binary Tree After Subtree Removal Queries](https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/);\r\n */\r\nclass Solution {\r\n    /* Complexity:\r\n     * Time O(N+M) and Space O(N+M) where N is the number of nodes in root\r\n     * and M is the size of queries.\r\n     */\r\n    fun treeQueries(\r\n        root: TreeNode?,\r\n        queries: IntArray,\r\n    ): IntArray {\r\n        requireNotNull(root)\r\n        val subtreeHeights = computeSubtreeHeights(root)\r\n        val rootHeight = checkNotNull(subtreeHeights[root])\r\n        // query(node.val) = answers[node.val] ?: root.height\r\n        // check(answers.size <= rootHeight + 1)\r\n        val answers = answerAllNodes(root, subtreeHeights)\r\n        return IntArray(queries.size) {\r\n            answers[queries[it]] ?: rootHeight\r\n        }\r\n    }\r\n\r\n    private fun computeSubtreeHeights(root: TreeNode?): Map<TreeNode, Int> =\r\n        buildMap {\r\n            dfsHeight(root) { node, height ->\r\n                put(node, height)\r\n            }\r\n        }\r\n\r\n    private fun dfsHeight(\r\n        root: TreeNode?,\r\n        onEachNode: (node: TreeNode, height: Int) -> Unit,\r\n    ): Int {\r\n        if (root == null) {\r\n            return -1 // to cancel the plus 1 in height\r\n        }\r\n        val height =\r\n            max(\r\n                dfsHeight(root.left, onEachNode),\r\n                dfsHeight(root.right, onEachNode),\r\n            ) + 1\r\n        onEachNode(root, height)\r\n        return height\r\n    }\r\n\r\n    private fun answerAllNodes(\r\n        root: TreeNode,\r\n        subtreeHeights: Map<TreeNode, Int>,\r\n    ): MutableMap<Int, Int> =\r\n        mutableMapOf<Int, Int>().apply {\r\n            put(root.`val`, -1)\r\n            dfsAnswers(root, 0, -1, subtreeHeights, this)\r\n        }\r\n\r\n    private fun dfsAnswers(\r\n        root: TreeNode?,\r\n        pathLength: Int,\r\n        maxHeightByLosers: Int, // longest path not passing through the current node\r\n        subtreeHeights: Map<TreeNode, Int>,\r\n        answers: MutableMap<Int, Int>,\r\n    ) {\r\n        if (root == null) {\r\n            return\r\n        }\r\n\r\n        val leftHeight = root.left?.let { checkNotNull(subtreeHeights[it]) } ?: -1\r\n        val rightHeight = root.right?.let { checkNotNull(subtreeHeights[it]) } ?: -1\r\n        if (leftHeight == rightHeight) {\r\n            return // delete either child or one of their descendants doesn't affect the overall height\r\n        }\r\n        val winner = if (leftHeight > rightHeight) root.left else root.right\r\n        checkNotNull(winner)\r\n        val heightByLoser = pathLength + 1 + min(leftHeight, rightHeight)\r\n        val answerWinner = max(maxHeightByLosers, heightByLoser)\r\n        answers[winner.`val`] = answerWinner\r\n        // answerLoserAndItsDescendants = height of the original tree\r\n        dfsAnswers(winner, pathLength + 1, answerWinner, subtreeHeights, answers)\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/kotlin/com/hj/leetcode/kotlin/problem2458/Solution.kt b/src/main/kotlin/com/hj/leetcode/kotlin/problem2458/Solution.kt
--- a/src/main/kotlin/com/hj/leetcode/kotlin/problem2458/Solution.kt	(revision 1e3ba8c3b5515066cbc88622c97b2aa40239eba8)
+++ b/src/main/kotlin/com/hj/leetcode/kotlin/problem2458/Solution.kt	(date 1729935132231)
@@ -18,10 +18,10 @@
     ): IntArray {
         requireNotNull(root)
         val subtreeHeights = computeSubtreeHeights(root)
-        val rootHeight = checkNotNull(subtreeHeights[root])
         // query(node.val) = answers[node.val] ?: root.height
-        // check(answers.size <= rootHeight + 1)
         val answers = answerAllNodes(root, subtreeHeights)
+        val rootHeight = checkNotNull(subtreeHeights[root])
+        // check(answers.size <= rootHeight + 1)
         return IntArray(queries.size) {
             answers[queries[it]] ?: rootHeight
         }
